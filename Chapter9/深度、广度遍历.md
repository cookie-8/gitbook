# 第 2 节：bfs dfs

### 以 dom 节点的遍历为例

1. `深度优先遍历` dfs

> 递归

```js
function dfs(node, List = []) {
  if (node) {
    List.push(node)
    const children = node.children
    for (let i = 0; i < children.length; i++) {
      dfs(children[i], List)
    }
  }
  return List
}
// test
dfs(document.documentElement)
```

> 非递归

```js
function dfs(node) {
  const List = []
  if (node) {
    const stack = []
    stack.push(node)

    while (stack.length) {
      const item = stack.pop()
      List.push(item)
      const children = item.children
      for (let i = children.length - 1; i >= 0; i--) {
        stack.push(children[i])
      }
    }
  }

  return List
}
```

2. `广度优先遍历` bfs

> 递归 ,采用循环遍历+指针的方式

```js
function bfs(node) {
  if (!node) return
  const result = [node]
  function _bfs(index) {
    const el = result[index]
    if (el) {
      const cs = el.children
      for (let i = 0; i < cs.length; i++) {
        result.push(cs[i])
      }
      _bfs(++index)
    }
  }
  _bfs(0)
  return result
}
// test
bfs(document.documentElement)
```

> 非递归，普通

```js
function bfs(node) {
  const List = []
  if (node) {
    const queue = []
    queue.unshift(node)
    while (queue.length) {
      const item = queue.shift()
      List.push(item)
      const children = item.children
      for (let i = 0; i < children.length; i++) {
        queue.push(children[i])
      }
    }
  }
}
```

> 非递归 ，指针方式

```js
function bfs(node) {
  if (!node) return
  const result = [node]
  let index = 0
  while (index < result.length) {
    const cs = result[index].children
    for (let i = 0; i < cs.length; i++) {
      result.push(cs[i])
    }
    index++
  }
  return result
}
// test
bfs(document.documentElement)
```
